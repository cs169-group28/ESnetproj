<style>

@import url(../../../../style.css?20120427);

#circle circle {
  fill: none;
  pointer-events: all;
}

.group path {
  fill-opacity: .5;
}

path.chord {
  stroke: #000;
  stroke-width: .25px;
}

#circle:hover path.fade {
  display: none;
}

</style>

<h2>
<%= @request_type %>
	 response</h2>

<b> Server 1 (origin): </b>
<br />
<%=@s1.hostname%>
<br />
<%=@s1.ip%>
<br />

<b> Server 2 (destination): </b>
<br />
<%=@s2.hostname%>
<br />
<%=@s2.ip%>
<br />

<button class="btn btn-primary" data-toggle="collapse" data-target="#table">Raw data <i class="icon-white icon-chevron-up"></i></button>

<br />
<br />

<script>
  function rainbow(n, max) {
    // ranges between 0 and max
    // smaller numbers are towards green
    // larger numbers are towards reds
      n = Math.min(n, max)
      n = Math.max(n, 0)
      n = 120 - n * 120 / max;
      return 'hsl(' + n + ',100%,50%)';
  }
</script>

<div id="table" class="row-fluid collapse in">
<div class="span10">
<table class="table table-hover table-bordered table-condensed">
<% if @request_type == "OWAMP" %>
<tr>
  <th>Min TTL</th>
  <th>Min Delay</th>
  <th>Max Error</th>
  <th>Max Delay</th>
  <th>Duplicates</th>
  <th>End Time</th>
  <th>Loss</th>
  <th>Sent</th>
  <th>Start Time</th>
  <th>Max TTL</th>
</tr>
<% @response.each do |entry| %>
<tr>
	<td><%= entry[:minTTL] %></td>
	<td><%= entry[:min_delay] %></td>
	<td><%= entry[:maxError] %></td>
	<td><%= entry[:max_delay] %></td>
	<td><%= entry[:duplicates] %></td>
	<td><%= entry[:endTime] %></td>
	<td><%= entry[:loss] %></td>
	<td><%= entry[:sent] %></td>
	<td><%= entry[:startTime] %></td>
	<td><%= entry[:maxTTL] %></td>
</tr>
<% end %>

<% elsif @request_type == "BWCTL" %>
<tr>
  <th>Time Value</th>
  <th>Throughput</th>
</tr>
<% @response.each do |entry| %>
<tr>
	<td><%= entry[:timeValue] %></td>
	<td><%= entry[:throughput] %></td>
</tr>
<% end %>
<% else %>
<tr>
  <th>Time</th>
  <th>Query Num</th>
  <th>Hop</th>
  <th>Duration (s)</th>
</tr>
<% @response.each do |entry| %>
<tr>
	<td><%= entry[:timeValue] %></td>
  <td><%= entry[:queryNum] %></td>
  <td><%= entry[:hop] %></td>
  <td><%= entry[:value] %></td>
</tr>
<% end %>
<% end %>
</table>
</div>
</div>

<button class="btn btn-primary" data-toggle="collapse" data-target="#graph">Graph <i class="icon-white icon-chevron-up"></i></button>

<div id="graph" class="collapse in">

<script src="http://d3js.org/d3.v2.min.js?2.8.1"></script>

  <script>
  var width = 720,
      height = 720,
      outerRadius = Math.min(width, height) / 2 - 10,
      innerRadius = outerRadius - 24;

  var formatPercent = d3.format(".1%");

  var arc = d3.svg.arc()
      .innerRadius(innerRadius)
      .outerRadius(outerRadius);

  var layout = d3.layout.chord()
      .padding(.04)
      .sortSubgroups(d3.descending)
      .sortChords(d3.ascending);

  var path = d3.svg.chord()
      .radius(innerRadius);

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height)
    .append("g")
      .attr("id", "circle")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

  svg.append("circle")
      .attr("r", outerRadius);

  var servers = <%=@masterNodes%>;
  var matrixOfValues = <%=@masterMatrixOfValues%>;
  var matrixOfColorsValues = <%=@masterMatrixOfColorValues%>;

  // Compute the chord layout.
  layout.matrix(matrixOfValues);

  // Add a group per neighborhood.
  var group = svg.selectAll(".group")
      .data(layout.groups)
    .enter().append("g")
      .attr("class", "group")
      .on("mouseover", mouseover)
      .on("mouseout", mouseout);

  function mouseout(d, i) {
    chord.classed("fade", function(p) {
    });
  }

  // Add a mouseover title.
  group.append("title").text(function(d, i) {
    return servers[i].name + ": " + formatPercent(d.value) + " of origins";
  });

  // Add the group arc.
  var groupPath = group.append("path")
      .attr("id", function(d, i) { return "group" + i; })
      .attr("d", arc)
      .style("fill", function(d, i) {
        if (isOrigin(servers[i].name) || isDestination(servers[i].name))
          // ORIGIN and DESTINATION NODE COLOR
          return "#0099FF"
        else
          // OTHER NODES COLOR
          return "#FFFFFF";
      });

  // Add a text label.
  var groupText = group.append("text")
      .attr("x", 6)
      .attr("dy", 15);

  groupText.append("textPath")
      .attr("xlink:href", function(d, i) { return "#group" + i; })
      .text(function(d, i) {
      if (isOrigin(servers[i].name)) {
        return "SRC: " + servers[i].name;
      } else if (isDestination(servers[i].name)) {
        return "DST: " + servers[i].name;
      } else {
        return servers[i].name;
      }
    });

  // Remove the labels that don't fit. :(
  groupText.filter(function(d, i) { return groupPath[0][i].getTotalLength() / 2 - 16 < this.getComputedTextLength(); })
      .remove();

  // Add the chords.
  var chord = svg.selectAll(".chord")
      .data(layout.chords)
    .enter().append("path")
      .attr("class", "chord")
      .style("fill", function(d) { 
        // select color of chord depending on color matrix
        return rainbow(matrixOfColorsValues[d.source.index][d.target.index], 5)
        //return servers[d.source.index].color; 
      })
      .attr("d", path)

  // Add an elaborate mouseover title for each chord.
  chord.append("title").text(function(d) {
    return servers[d.source.index].name
        + " → " + servers[d.target.index].name
        + ": " + formatPercent(d.source.value)
        + "\n" + servers[d.target.index].name
        + " → " + servers[d.source.index].name
        + ": " + formatPercent(d.target.value);
  });

  function mouseover(d, i) {
    chord.classed("fade", function(p) {
      return p.source.index != i
          && p.target.index != i;
    });
  }

  function isOrigin(ip) {
    return ip == "<%=@src%>";
  }

  function isDestination(ip) {
    return ip == "<%=@dst%>";
  }

</script>
</div>