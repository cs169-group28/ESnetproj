<h2>
<%= @request_type %>
	 response</h2>

<br />

<b> Server 1 (origin): </b>
<br />
<%=@s1.hostname%>
<br />
<%=@s1.ip%>
<br />

<br />

<b> Server 2 (destination): </b>
<br />
<%=@s2.hostname%>
<br />
<%=@s2.ip%>
<br />

<br />



<br />
<% @times = [] %>
<% @datum = [] %>
<table class="table table-striped table-bordered table-condensed">
<% if @request_type == "OWAMP" %>
<tr>
  <th>Min TTL</th>
  <th>Min Delay</th>
  <th>Max Error</th>
  <th>Max Delay</th>
  <th>Duplicates</th>
  <th>End Time</th>
  <th>Loss</th>
  <th>Sent</th>
  <th>Start Time</th>
  <th>Max TTL</th>
</tr>
<% @response.each do |entry| %>
<tr>
	<td><%= entry[:minTTL] %></td>
	<td><%= entry[:min_delay] %></td>
	<td><%= entry[:maxError] %></td>
	<td><%= entry[:max_delay] %></td>
	<td><%= entry[:duplicates] %></td>
	<td><%= entry[:endTime] %></td>
	<td><%= entry[:loss] %></td>
	<td><%= entry[:sent] %></td>
	<td><%= entry[:startTime] %></td>
	<td><%= entry[:maxTTL] %></td>
</tr>
<% end %>

<% elsif @request_type == "BWCTL" %>
<tr>
  <th>Time Value</th>
  <th>Throughput</th>
</tr>
<% @response.each do |entry| %>
<tr>
	<td><%= entry[:timeValue] %></td>
	<td><%= entry[:throughput].to_f/1000000000 %> GBPs</td>
  <% @datum.append(entry[:throughput].to_f/1000000000) %>
  <% @times.append(Time.parse(entry[:timeValue]).to_i)%>
</tr>
<% end %>
<% else %>
<tr>
  <th>Query Num</th>
  <th>Hop</th>
  <th>Value</th>
  <th>Value Units</th>
  <th>Time Value</th>
</tr>
<% @response.each do |entry| %>
<tr>
	<td><%= entry[:queryNum] %></td>
	<td><%= entry[:hop] %></td>
	<td><%= entry[:value] %></td>
	<td><%= entry[:valueUnits] %></td>
	<td><%= entry[:timeValue] %></td>
</tr>
<% end %>
<% end %>
</table>


<%if @request_type == "BWCTL" %>
 <div id="graph" class="aGraph"></div>
<% end %>


<script>
/* implementation heavily influenced by http://bl.ocks.org/1166403 */

// define dimensions of graph
var m = [80, 80, 80, 80]; // margins
var w = 1000 - m[1] - m[3]; // width
var h = 400 - m[0] - m[2]; // height

// create a simple data array that we'll plot with a line (this array represents only the Y values, X will just be the index location)

var data = <%= @datum %>;
// X scale will fit all values from data[] within pixels 0-w
var x = d3.scale.linear().domain([0, data.length]).range([0, w]);
// Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
var y = d3.scale.linear().domain([1.5, 3.0]).range([h, 0]);
// automatically determining max range can work something like this
// var y = d3.scale.linear().domain([0, d3.max(data)]).range([h, 0]);

// create a line function that can convert data[] into x and y points
var line = d3.svg.line()
// assign the X function to plot our line as we wish
.x(function(d,i) {
// verbose logging to show what's actually being done
console.log('Plotting X value for data point: ' + d + ' using index: ' + i + ' to be at: ' + x(i) + ' using our xScale.');
// return the X coordinate where we want to plot this datapoint
return x(i);
})
.y(function(d) {
// verbose logging to show what's actually being done
console.log('Plotting Y value for data point: ' + d + ' to be at: ' + y(d) + " using our yScale.");
// return the Y coordinate where we want to plot this datapoint
return y(d);
})

// Add an SVG element with the desired dimensions and margin.
var graph = d3.select("#graph").append("svg:svg")
.attr("width", w + m[1] + m[3])
.attr("height", h + m[0] + m[2])
.append("svg:g")
.attr("transform", "translate(" + m[3] + "," + m[0] + ")");

// create yAxis
var tickVals = <%= @times %>;
for(var i =0; i<tickVals.length; i++){
  tickVals[i] = new Date(tickVals[i] * 1000)
  console.log('Date is' + tickVals[i] + '');
}
var xAxis = d3.svg.axis().scale(x).tickSize(-h).tickSubdivide(true);
// Add the x-axis.
graph.append("svg:g")
.attr("class", "x axis")
.attr("transform", "translate(0," + h + ")")
.call(xAxis);


// create left yAxis
var yAxisLeft = d3.svg.axis().scale(y).ticks(4).orient("left");
// Add the y-axis to the left
graph.append("svg:g")
.attr("class", "y axis")
.attr("transform", "translate(-25,0)")
.call(yAxisLeft);

   // Add the line by appending an svg:path element with the data line we created above
// do this AFTER the axes above so that the line is above the tick-lines
   graph.append("svg:path").attr("d", line(data));


</script>

